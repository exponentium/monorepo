"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@turnkey+iframe-stamper@2.0.0";
exports.ids = ["vendor-chunks/@turnkey+iframe-stamper@2.0.0"];
exports.modules = {

/***/ "(ssr)/../../node_modules/.pnpm/@turnkey+iframe-stamper@2.0.0/node_modules/@turnkey/iframe-stamper/dist/index.mjs":
/*!******************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@turnkey+iframe-stamper@2.0.0/node_modules/@turnkey/iframe-stamper/dist/index.mjs ***!
  \******************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   IframeEventType: () => (/* binding */ IframeEventType),\n/* harmony export */   IframeStamper: () => (/* binding */ IframeStamper),\n/* harmony export */   KeyFormat: () => (/* binding */ KeyFormat)\n/* harmony export */ });\n/// <reference lib=\"dom\" />\n// Header name for an API key stamp\nconst stampHeaderName = \"X-Stamp\";\n// Set of constants for event types expected to be sent and received between a parent page and its iframe.\nvar IframeEventType;\n(function (IframeEventType) {\n    // Event sent by the iframe to its parent to indicate readiness.\n    // Value: the iframe public key\n    IframeEventType[\"PublicKeyReady\"] = \"PUBLIC_KEY_READY\";\n    // Event sent by the parent to inject a credential bundle (for recovery or auth) into the iframe.\n    // Value: the bundle to inject\n    IframeEventType[\"InjectCredentialBundle\"] = \"INJECT_CREDENTIAL_BUNDLE\";\n    // Event sent by the parent to inject a private key export bundle into the iframe.\n    // Value: the bundle to inject\n    // Key Format (optional): the key format to encode the private key in after it's exported and decrypted: HEXADECIMAL or SOLANA. Defaults to HEXADECIMAL.\n    // Public Key (optional): the public key of the exported private key. Required when the key format is SOLANA.\n    IframeEventType[\"InjectKeyExportBundle\"] = \"INJECT_KEY_EXPORT_BUNDLE\";\n    // Event sent by the parent to inject a wallet export bundle into the iframe.\n    // Value: the bundle to inject\n    IframeEventType[\"InjectWalletExportBundle\"] = \"INJECT_WALLET_EXPORT_BUNDLE\";\n    // Event sent by the parent to inject an import bundle into the iframe.\n    // Value: the bundle to inject\n    IframeEventType[\"InjectImportBundle\"] = \"INJECT_IMPORT_BUNDLE\";\n    // Event sent by the parent to extract an encrypted wallet bundle from the iframe.\n    // Value: none\n    IframeEventType[\"ExtractWalletEncryptedBundle\"] = \"EXTRACT_WALLET_ENCRYPTED_BUNDLE\";\n    // Event sent by the parent to extract an encrypted private key bundle from the iframe.\n    // Value: none\n    // Key Format (optional): the key format to decode the private key in before it's encrypted for import: HEXADECIMAL or SOLANA. Defaults to HEXADECIMAL.\n    IframeEventType[\"ExtractKeyEncryptedBundle\"] = \"EXTRACT_KEY_ENCRYPTED_BUNDLE\";\n    // Event sent by the parent to apply settings on the iframe.\n    // Value: the settings to apply in JSON string format.\n    IframeEventType[\"ApplySettings\"] = \"APPLY_SETTINGS\";\n    // Event sent by the iframe to its parent when `InjectBundle` is successful\n    // Value: true (boolean)\n    IframeEventType[\"BundleInjected\"] = \"BUNDLE_INJECTED\";\n    // Event sent by the iframe to its parent when `ExtractEncryptedBundle` is successful\n    // Value: the bundle encrypted in the iframe\n    IframeEventType[\"EncryptedBundleExtracted\"] = \"ENCRYPTED_BUNDLE_EXTRACTED\";\n    // Event sent by the iframe to its parent when `ApplySettings` is successful\n    // Value: true (boolean)\n    IframeEventType[\"SettingsApplied\"] = \"SETTINGS_APPLIED\";\n    // Event sent by the parent page to request a signature\n    // Value: payload to sign\n    IframeEventType[\"StampRequest\"] = \"STAMP_REQUEST\";\n    // Event sent by the iframe to communicate the result of a stamp operation.\n    // Value: signed payload\n    IframeEventType[\"Stamp\"] = \"STAMP\";\n    // Event sent by the iframe to communicate an error\n    // Value: serialized error\n    IframeEventType[\"Error\"] = \"ERROR\";\n})(IframeEventType || (IframeEventType = {}));\n// Set of constants for private key formats. These formats map to the encoding type used on a private key before encrypting and importing it\n// or after exporting it and decrypting it.\nvar KeyFormat;\n(function (KeyFormat) {\n    // 64 hexadecimal digits. Key format used by MetaMask, MyEtherWallet, Phantom, Ledger, and Trezor for Ethereum and Tron keys\n    KeyFormat[\"Hexadecimal\"] = \"HEXADECIMAL\";\n    // Key format used by Phantom and Solflare for Solana keys\n    KeyFormat[\"Solana\"] = \"SOLANA\";\n})(KeyFormat || (KeyFormat = {}));\n/**\n * Stamper to use with `@turnkey/http`'s `TurnkeyClient`\n * Creating a stamper inserts an iframe in the current page.\n */\nclass IframeStamper {\n    /**\n     * Creates a new iframe stamper. This function _does not_ insert the iframe in the DOM.\n     * Call `.init()` to insert the iframe element in the DOM.\n     */\n    constructor(config) {\n        if (typeof window === \"undefined\") {\n            throw new Error(\"Cannot initialize iframe in non-browser environment\");\n        }\n        if (!config.iframeContainer) {\n            throw new Error(\"Iframe container cannot be found\");\n        }\n        this.container = config.iframeContainer;\n        if (this.container.querySelector(`#${config.iframeElementId}`)) {\n            throw new Error(`Iframe element with ID ${config.iframeElementId} already exists`);\n        }\n        let iframe = window.document.createElement(\"iframe\");\n        // See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe#sandbox\n        // We do not need any other permission than running scripts for import/export/auth frames.\n        iframe.setAttribute(\"sandbox\", \"allow-scripts allow-same-origin\");\n        iframe.id = config.iframeElementId;\n        iframe.src = config.iframeUrl;\n        this.iframe = iframe;\n        const iframeUrl = new URL(config.iframeUrl);\n        this.iframeOrigin = iframeUrl.origin;\n        // This is populated once the iframe is ready. Call `.init()` to kick off DOM insertion!\n        this.iframePublicKey = null;\n    }\n    /**\n     * Inserts the iframe on the page and returns a promise resolving to the iframe's public key\n     */\n    async init() {\n        this.container.appendChild(this.iframe);\n        return new Promise((resolve, _reject) => {\n            window.addEventListener(\"message\", (event) => {\n                if (event.origin !== this.iframeOrigin) {\n                    // There might be other things going on in the window, for example: react dev tools, other extensions, etc.\n                    // Instead of erroring out\n                    return;\n                }\n                if (event.data?.type === IframeEventType.PublicKeyReady) {\n                    this.iframePublicKey = event.data[\"value\"];\n                    resolve(event.data[\"value\"]);\n                }\n            }, false);\n        });\n    }\n    /**\n     * Removes the iframe from the DOM\n     */\n    clear() {\n        this.iframe.remove();\n    }\n    /**\n     * Returns the public key, or `null` if the underlying iframe isn't properly initialized.\n     */\n    publicKey() {\n        return this.iframePublicKey;\n    }\n    /**\n     * Function to inject a new credential into the iframe\n     * The bundle should be encrypted to the iframe's initial public key\n     * Encryption should be performed with HPKE (RFC 9180).\n     * This is used during recovery and auth flows.\n     */\n    async injectCredentialBundle(bundle) {\n        return new Promise((resolve, reject) => {\n            this.iframe.contentWindow?.postMessage({\n                type: IframeEventType.InjectCredentialBundle,\n                value: bundle,\n            }, \"*\");\n            window.addEventListener(\"message\", (event) => {\n                if (event.origin !== this.iframeOrigin) {\n                    // There might be other things going on in the window, for example: react dev tools, other extensions, etc.\n                    // Instead of erroring out we simply return. Not our event!\n                    return;\n                }\n                if (event.data?.type === IframeEventType.BundleInjected) {\n                    resolve(event.data[\"value\"]);\n                }\n                if (event.data?.type === IframeEventType.Error) {\n                    reject(event.data[\"value\"]);\n                }\n            }, false);\n        });\n    }\n    /**\n     * Function to inject an export bundle into the iframe\n     * The bundle should be encrypted to the iframe's initial public key\n     * Encryption should be performed with HPKE (RFC 9180).\n     * The key format to encode the private key in after it's exported and decrypted: HEXADECIMAL or SOLANA. Defaults to HEXADECIMAL.\n     * This is used during the private key export flow.\n     */\n    async injectKeyExportBundle(bundle, organizationId, keyFormat) {\n        this.iframe.contentWindow?.postMessage({\n            type: IframeEventType.InjectKeyExportBundle,\n            value: bundle,\n            keyFormat,\n            organizationId,\n        }, \"*\");\n        return new Promise((resolve, reject) => {\n            window.addEventListener(\"message\", (event) => {\n                if (event.origin !== this.iframeOrigin) {\n                    // There might be other things going on in the window, for example: react dev tools, other extensions, etc.\n                    // Instead of erroring out we simply return. Not our event!\n                    return;\n                }\n                if (event.data?.type === IframeEventType.BundleInjected) {\n                    resolve(event.data[\"value\"]);\n                }\n                if (event.data?.type === IframeEventType.Error) {\n                    reject(event.data[\"value\"]);\n                }\n            }, false);\n        });\n    }\n    /**\n     * Function to inject an export bundle into the iframe\n     * The bundle should be encrypted to the iframe's initial public key\n     * Encryption should be performed with HPKE (RFC 9180).\n     * This is used during the wallet export flow.\n     */\n    async injectWalletExportBundle(bundle, organizationId) {\n        this.iframe.contentWindow?.postMessage({\n            type: IframeEventType.InjectWalletExportBundle,\n            value: bundle,\n            organizationId,\n        }, \"*\");\n        return new Promise((resolve, reject) => {\n            window.addEventListener(\"message\", (event) => {\n                if (event.origin !== this.iframeOrigin) {\n                    // There might be other things going on in the window, for example: react dev tools, other extensions, etc.\n                    // Instead of erroring out we simply return. Not our event!\n                    return;\n                }\n                if (event.data?.type === IframeEventType.BundleInjected) {\n                    resolve(event.data[\"value\"]);\n                }\n                if (event.data?.type === IframeEventType.Error) {\n                    reject(event.data[\"value\"]);\n                }\n            }, false);\n        });\n    }\n    /**\n     * Function to inject an import bundle into the iframe\n     * This is used to initiate either the wallet import flow or the private key import flow.\n     */\n    async injectImportBundle(bundle, organizationId, userId) {\n        this.iframe.contentWindow?.postMessage({\n            type: IframeEventType.InjectImportBundle,\n            value: bundle,\n            organizationId,\n            userId,\n        }, \"*\");\n        return new Promise((resolve, reject) => {\n            window.addEventListener(\"message\", (event) => {\n                if (event.origin !== this.iframeOrigin) {\n                    // There might be other things going on in the window, for example: react dev tools, other extensions, etc.\n                    // Instead of erroring out we simply return. Not our event!\n                    return;\n                }\n                if (event.data?.type === IframeEventType.BundleInjected) {\n                    resolve(event.data[\"value\"]);\n                }\n                if (event.data?.type === IframeEventType.Error) {\n                    reject(event.data[\"value\"]);\n                }\n            }, false);\n        });\n    }\n    /**\n     * Function to extract an encrypted bundle from the iframe\n     * The bundle should be encrypted to Turnkey's Signer enclave's initial public key\n     * Encryption should be performed with HPKE (RFC 9180).\n     * This is used during the wallet import flow.\n     */\n    async extractWalletEncryptedBundle() {\n        this.iframe.contentWindow?.postMessage({\n            type: IframeEventType.ExtractWalletEncryptedBundle,\n        }, \"*\");\n        return new Promise((resolve, reject) => {\n            window.addEventListener(\"message\", (event) => {\n                if (event.origin !== this.iframeOrigin) {\n                    // There might be other things going on in the window, for example: react dev tools, other extensions, etc.\n                    // Instead of erroring out we simply return. Not our event!\n                    return;\n                }\n                if (event.data?.type === IframeEventType.EncryptedBundleExtracted) {\n                    resolve(event.data[\"value\"]);\n                }\n                if (event.data?.type === IframeEventType.Error) {\n                    reject(event.data[\"value\"]);\n                }\n            }, false);\n        });\n    }\n    /**\n     * Function to extract an encrypted bundle from the iframe\n     * The bundle should be encrypted to Turnkey's Signer enclave's initial public key\n     * Encryption should be performed with HPKE (RFC 9180).\n     * The key format to encode the private key in before it's encrypted and imported: HEXADECIMAL or SOLANA. Defaults to HEXADECIMAL.\n     * This is used during the private key import flow.\n     */\n    async extractKeyEncryptedBundle(keyFormat) {\n        this.iframe.contentWindow?.postMessage({\n            type: IframeEventType.ExtractKeyEncryptedBundle,\n            keyFormat: keyFormat,\n        }, \"*\");\n        return new Promise((resolve, reject) => {\n            window.addEventListener(\"message\", (event) => {\n                if (event.origin !== this.iframeOrigin) {\n                    // There might be other things going on in the window, for example: react dev tools, other extensions, etc.\n                    // Instead of erroring out we simply return. Not our event!\n                    return;\n                }\n                if (event.data?.type === IframeEventType.EncryptedBundleExtracted) {\n                    resolve(event.data[\"value\"]);\n                }\n                if (event.data?.type === IframeEventType.Error) {\n                    reject(event.data[\"value\"]);\n                }\n            }, false);\n        });\n    }\n    /**\n     * Function to apply settings on allowed parameters in the iframe\n     * This is used to style the HTML element used for plaintext in wallet and private key import.\n     */\n    async applySettings(settings) {\n        const settingsStr = JSON.stringify(settings);\n        this.iframe.contentWindow?.postMessage({\n            type: IframeEventType.ApplySettings,\n            value: settingsStr,\n        }, \"*\");\n        return new Promise((resolve, reject) => {\n            window.addEventListener(\"message\", (event) => {\n                if (event.origin !== this.iframeOrigin) {\n                    // There might be other things going on in the window, for example: react dev tools, other extensions, etc.\n                    // Instead of erroring out we simply return. Not our event!\n                    return;\n                }\n                if (event.data?.type === IframeEventType.SettingsApplied) {\n                    resolve(event.data[\"value\"]);\n                }\n                if (event.data?.type === IframeEventType.Error) {\n                    reject(event.data[\"value\"]);\n                }\n            }, false);\n        });\n    }\n    /**\n     * Function to sign a payload with the underlying iframe\n     */\n    async stamp(payload) {\n        if (this.iframePublicKey === null) {\n            throw new Error(\"null iframe public key. Have you called/awaited .init()?\");\n        }\n        const iframeOrigin = this.iframeOrigin;\n        this.iframe.contentWindow?.postMessage({\n            type: IframeEventType.StampRequest,\n            value: payload,\n        }, \"*\");\n        return new Promise(function (resolve, reject) {\n            window.addEventListener(\"message\", (event) => {\n                if (event.origin !== iframeOrigin) {\n                    // There might be other things going on in the window, for example: react dev tools, other extensions, etc.\n                    // Instead of erroring out we simply return. Not our event!\n                    return;\n                }\n                if (event.data?.type === IframeEventType.Stamp) {\n                    resolve({\n                        stampHeaderName: stampHeaderName,\n                        stampHeaderValue: event.data[\"value\"],\n                    });\n                }\n                if (event.data?.type === IframeEventType.Error) {\n                    reject(event.data[\"value\"]);\n                }\n            }, false);\n        });\n    }\n}\n\n\n//# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0B0dXJua2V5K2lmcmFtZS1zdGFtcGVyQDIuMC4wL25vZGVfbW9kdWxlcy9AdHVybmtleS9pZnJhbWUtc3RhbXBlci9kaXN0L2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDBDQUEwQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw4QkFBOEI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2Qyx1QkFBdUI7QUFDcEUsc0RBQXNELHdCQUF3QjtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTs7QUFFcUQ7QUFDckQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Ac3BoZXJvaWQvY2xpZW50Ly4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9AdHVybmtleStpZnJhbWUtc3RhbXBlckAyLjAuMC9ub2RlX21vZHVsZXMvQHR1cm5rZXkvaWZyYW1lLXN0YW1wZXIvZGlzdC9pbmRleC5tanM/NDYzNCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLy8gPHJlZmVyZW5jZSBsaWI9XCJkb21cIiAvPlxuLy8gSGVhZGVyIG5hbWUgZm9yIGFuIEFQSSBrZXkgc3RhbXBcbmNvbnN0IHN0YW1wSGVhZGVyTmFtZSA9IFwiWC1TdGFtcFwiO1xuLy8gU2V0IG9mIGNvbnN0YW50cyBmb3IgZXZlbnQgdHlwZXMgZXhwZWN0ZWQgdG8gYmUgc2VudCBhbmQgcmVjZWl2ZWQgYmV0d2VlbiBhIHBhcmVudCBwYWdlIGFuZCBpdHMgaWZyYW1lLlxudmFyIElmcmFtZUV2ZW50VHlwZTtcbihmdW5jdGlvbiAoSWZyYW1lRXZlbnRUeXBlKSB7XG4gICAgLy8gRXZlbnQgc2VudCBieSB0aGUgaWZyYW1lIHRvIGl0cyBwYXJlbnQgdG8gaW5kaWNhdGUgcmVhZGluZXNzLlxuICAgIC8vIFZhbHVlOiB0aGUgaWZyYW1lIHB1YmxpYyBrZXlcbiAgICBJZnJhbWVFdmVudFR5cGVbXCJQdWJsaWNLZXlSZWFkeVwiXSA9IFwiUFVCTElDX0tFWV9SRUFEWVwiO1xuICAgIC8vIEV2ZW50IHNlbnQgYnkgdGhlIHBhcmVudCB0byBpbmplY3QgYSBjcmVkZW50aWFsIGJ1bmRsZSAoZm9yIHJlY292ZXJ5IG9yIGF1dGgpIGludG8gdGhlIGlmcmFtZS5cbiAgICAvLyBWYWx1ZTogdGhlIGJ1bmRsZSB0byBpbmplY3RcbiAgICBJZnJhbWVFdmVudFR5cGVbXCJJbmplY3RDcmVkZW50aWFsQnVuZGxlXCJdID0gXCJJTkpFQ1RfQ1JFREVOVElBTF9CVU5ETEVcIjtcbiAgICAvLyBFdmVudCBzZW50IGJ5IHRoZSBwYXJlbnQgdG8gaW5qZWN0IGEgcHJpdmF0ZSBrZXkgZXhwb3J0IGJ1bmRsZSBpbnRvIHRoZSBpZnJhbWUuXG4gICAgLy8gVmFsdWU6IHRoZSBidW5kbGUgdG8gaW5qZWN0XG4gICAgLy8gS2V5IEZvcm1hdCAob3B0aW9uYWwpOiB0aGUga2V5IGZvcm1hdCB0byBlbmNvZGUgdGhlIHByaXZhdGUga2V5IGluIGFmdGVyIGl0J3MgZXhwb3J0ZWQgYW5kIGRlY3J5cHRlZDogSEVYQURFQ0lNQUwgb3IgU09MQU5BLiBEZWZhdWx0cyB0byBIRVhBREVDSU1BTC5cbiAgICAvLyBQdWJsaWMgS2V5IChvcHRpb25hbCk6IHRoZSBwdWJsaWMga2V5IG9mIHRoZSBleHBvcnRlZCBwcml2YXRlIGtleS4gUmVxdWlyZWQgd2hlbiB0aGUga2V5IGZvcm1hdCBpcyBTT0xBTkEuXG4gICAgSWZyYW1lRXZlbnRUeXBlW1wiSW5qZWN0S2V5RXhwb3J0QnVuZGxlXCJdID0gXCJJTkpFQ1RfS0VZX0VYUE9SVF9CVU5ETEVcIjtcbiAgICAvLyBFdmVudCBzZW50IGJ5IHRoZSBwYXJlbnQgdG8gaW5qZWN0IGEgd2FsbGV0IGV4cG9ydCBidW5kbGUgaW50byB0aGUgaWZyYW1lLlxuICAgIC8vIFZhbHVlOiB0aGUgYnVuZGxlIHRvIGluamVjdFxuICAgIElmcmFtZUV2ZW50VHlwZVtcIkluamVjdFdhbGxldEV4cG9ydEJ1bmRsZVwiXSA9IFwiSU5KRUNUX1dBTExFVF9FWFBPUlRfQlVORExFXCI7XG4gICAgLy8gRXZlbnQgc2VudCBieSB0aGUgcGFyZW50IHRvIGluamVjdCBhbiBpbXBvcnQgYnVuZGxlIGludG8gdGhlIGlmcmFtZS5cbiAgICAvLyBWYWx1ZTogdGhlIGJ1bmRsZSB0byBpbmplY3RcbiAgICBJZnJhbWVFdmVudFR5cGVbXCJJbmplY3RJbXBvcnRCdW5kbGVcIl0gPSBcIklOSkVDVF9JTVBPUlRfQlVORExFXCI7XG4gICAgLy8gRXZlbnQgc2VudCBieSB0aGUgcGFyZW50IHRvIGV4dHJhY3QgYW4gZW5jcnlwdGVkIHdhbGxldCBidW5kbGUgZnJvbSB0aGUgaWZyYW1lLlxuICAgIC8vIFZhbHVlOiBub25lXG4gICAgSWZyYW1lRXZlbnRUeXBlW1wiRXh0cmFjdFdhbGxldEVuY3J5cHRlZEJ1bmRsZVwiXSA9IFwiRVhUUkFDVF9XQUxMRVRfRU5DUllQVEVEX0JVTkRMRVwiO1xuICAgIC8vIEV2ZW50IHNlbnQgYnkgdGhlIHBhcmVudCB0byBleHRyYWN0IGFuIGVuY3J5cHRlZCBwcml2YXRlIGtleSBidW5kbGUgZnJvbSB0aGUgaWZyYW1lLlxuICAgIC8vIFZhbHVlOiBub25lXG4gICAgLy8gS2V5IEZvcm1hdCAob3B0aW9uYWwpOiB0aGUga2V5IGZvcm1hdCB0byBkZWNvZGUgdGhlIHByaXZhdGUga2V5IGluIGJlZm9yZSBpdCdzIGVuY3J5cHRlZCBmb3IgaW1wb3J0OiBIRVhBREVDSU1BTCBvciBTT0xBTkEuIERlZmF1bHRzIHRvIEhFWEFERUNJTUFMLlxuICAgIElmcmFtZUV2ZW50VHlwZVtcIkV4dHJhY3RLZXlFbmNyeXB0ZWRCdW5kbGVcIl0gPSBcIkVYVFJBQ1RfS0VZX0VOQ1JZUFRFRF9CVU5ETEVcIjtcbiAgICAvLyBFdmVudCBzZW50IGJ5IHRoZSBwYXJlbnQgdG8gYXBwbHkgc2V0dGluZ3Mgb24gdGhlIGlmcmFtZS5cbiAgICAvLyBWYWx1ZTogdGhlIHNldHRpbmdzIHRvIGFwcGx5IGluIEpTT04gc3RyaW5nIGZvcm1hdC5cbiAgICBJZnJhbWVFdmVudFR5cGVbXCJBcHBseVNldHRpbmdzXCJdID0gXCJBUFBMWV9TRVRUSU5HU1wiO1xuICAgIC8vIEV2ZW50IHNlbnQgYnkgdGhlIGlmcmFtZSB0byBpdHMgcGFyZW50IHdoZW4gYEluamVjdEJ1bmRsZWAgaXMgc3VjY2Vzc2Z1bFxuICAgIC8vIFZhbHVlOiB0cnVlIChib29sZWFuKVxuICAgIElmcmFtZUV2ZW50VHlwZVtcIkJ1bmRsZUluamVjdGVkXCJdID0gXCJCVU5ETEVfSU5KRUNURURcIjtcbiAgICAvLyBFdmVudCBzZW50IGJ5IHRoZSBpZnJhbWUgdG8gaXRzIHBhcmVudCB3aGVuIGBFeHRyYWN0RW5jcnlwdGVkQnVuZGxlYCBpcyBzdWNjZXNzZnVsXG4gICAgLy8gVmFsdWU6IHRoZSBidW5kbGUgZW5jcnlwdGVkIGluIHRoZSBpZnJhbWVcbiAgICBJZnJhbWVFdmVudFR5cGVbXCJFbmNyeXB0ZWRCdW5kbGVFeHRyYWN0ZWRcIl0gPSBcIkVOQ1JZUFRFRF9CVU5ETEVfRVhUUkFDVEVEXCI7XG4gICAgLy8gRXZlbnQgc2VudCBieSB0aGUgaWZyYW1lIHRvIGl0cyBwYXJlbnQgd2hlbiBgQXBwbHlTZXR0aW5nc2AgaXMgc3VjY2Vzc2Z1bFxuICAgIC8vIFZhbHVlOiB0cnVlIChib29sZWFuKVxuICAgIElmcmFtZUV2ZW50VHlwZVtcIlNldHRpbmdzQXBwbGllZFwiXSA9IFwiU0VUVElOR1NfQVBQTElFRFwiO1xuICAgIC8vIEV2ZW50IHNlbnQgYnkgdGhlIHBhcmVudCBwYWdlIHRvIHJlcXVlc3QgYSBzaWduYXR1cmVcbiAgICAvLyBWYWx1ZTogcGF5bG9hZCB0byBzaWduXG4gICAgSWZyYW1lRXZlbnRUeXBlW1wiU3RhbXBSZXF1ZXN0XCJdID0gXCJTVEFNUF9SRVFVRVNUXCI7XG4gICAgLy8gRXZlbnQgc2VudCBieSB0aGUgaWZyYW1lIHRvIGNvbW11bmljYXRlIHRoZSByZXN1bHQgb2YgYSBzdGFtcCBvcGVyYXRpb24uXG4gICAgLy8gVmFsdWU6IHNpZ25lZCBwYXlsb2FkXG4gICAgSWZyYW1lRXZlbnRUeXBlW1wiU3RhbXBcIl0gPSBcIlNUQU1QXCI7XG4gICAgLy8gRXZlbnQgc2VudCBieSB0aGUgaWZyYW1lIHRvIGNvbW11bmljYXRlIGFuIGVycm9yXG4gICAgLy8gVmFsdWU6IHNlcmlhbGl6ZWQgZXJyb3JcbiAgICBJZnJhbWVFdmVudFR5cGVbXCJFcnJvclwiXSA9IFwiRVJST1JcIjtcbn0pKElmcmFtZUV2ZW50VHlwZSB8fCAoSWZyYW1lRXZlbnRUeXBlID0ge30pKTtcbi8vIFNldCBvZiBjb25zdGFudHMgZm9yIHByaXZhdGUga2V5IGZvcm1hdHMuIFRoZXNlIGZvcm1hdHMgbWFwIHRvIHRoZSBlbmNvZGluZyB0eXBlIHVzZWQgb24gYSBwcml2YXRlIGtleSBiZWZvcmUgZW5jcnlwdGluZyBhbmQgaW1wb3J0aW5nIGl0XG4vLyBvciBhZnRlciBleHBvcnRpbmcgaXQgYW5kIGRlY3J5cHRpbmcgaXQuXG52YXIgS2V5Rm9ybWF0O1xuKGZ1bmN0aW9uIChLZXlGb3JtYXQpIHtcbiAgICAvLyA2NCBoZXhhZGVjaW1hbCBkaWdpdHMuIEtleSBmb3JtYXQgdXNlZCBieSBNZXRhTWFzaywgTXlFdGhlcldhbGxldCwgUGhhbnRvbSwgTGVkZ2VyLCBhbmQgVHJlem9yIGZvciBFdGhlcmV1bSBhbmQgVHJvbiBrZXlzXG4gICAgS2V5Rm9ybWF0W1wiSGV4YWRlY2ltYWxcIl0gPSBcIkhFWEFERUNJTUFMXCI7XG4gICAgLy8gS2V5IGZvcm1hdCB1c2VkIGJ5IFBoYW50b20gYW5kIFNvbGZsYXJlIGZvciBTb2xhbmEga2V5c1xuICAgIEtleUZvcm1hdFtcIlNvbGFuYVwiXSA9IFwiU09MQU5BXCI7XG59KShLZXlGb3JtYXQgfHwgKEtleUZvcm1hdCA9IHt9KSk7XG4vKipcbiAqIFN0YW1wZXIgdG8gdXNlIHdpdGggYEB0dXJua2V5L2h0dHBgJ3MgYFR1cm5rZXlDbGllbnRgXG4gKiBDcmVhdGluZyBhIHN0YW1wZXIgaW5zZXJ0cyBhbiBpZnJhbWUgaW4gdGhlIGN1cnJlbnQgcGFnZS5cbiAqL1xuY2xhc3MgSWZyYW1lU3RhbXBlciB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBpZnJhbWUgc3RhbXBlci4gVGhpcyBmdW5jdGlvbiBfZG9lcyBub3RfIGluc2VydCB0aGUgaWZyYW1lIGluIHRoZSBET00uXG4gICAgICogQ2FsbCBgLmluaXQoKWAgdG8gaW5zZXJ0IHRoZSBpZnJhbWUgZWxlbWVudCBpbiB0aGUgRE9NLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGluaXRpYWxpemUgaWZyYW1lIGluIG5vbi1icm93c2VyIGVudmlyb25tZW50XCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY29uZmlnLmlmcmFtZUNvbnRhaW5lcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSWZyYW1lIGNvbnRhaW5lciBjYW5ub3QgYmUgZm91bmRcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb250YWluZXIgPSBjb25maWcuaWZyYW1lQ29udGFpbmVyO1xuICAgICAgICBpZiAodGhpcy5jb250YWluZXIucXVlcnlTZWxlY3RvcihgIyR7Y29uZmlnLmlmcmFtZUVsZW1lbnRJZH1gKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJZnJhbWUgZWxlbWVudCB3aXRoIElEICR7Y29uZmlnLmlmcmFtZUVsZW1lbnRJZH0gYWxyZWFkeSBleGlzdHNgKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgaWZyYW1lID0gd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpZnJhbWVcIik7XG4gICAgICAgIC8vIFNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVE1ML0VsZW1lbnQvaWZyYW1lI3NhbmRib3hcbiAgICAgICAgLy8gV2UgZG8gbm90IG5lZWQgYW55IG90aGVyIHBlcm1pc3Npb24gdGhhbiBydW5uaW5nIHNjcmlwdHMgZm9yIGltcG9ydC9leHBvcnQvYXV0aCBmcmFtZXMuXG4gICAgICAgIGlmcmFtZS5zZXRBdHRyaWJ1dGUoXCJzYW5kYm94XCIsIFwiYWxsb3ctc2NyaXB0cyBhbGxvdy1zYW1lLW9yaWdpblwiKTtcbiAgICAgICAgaWZyYW1lLmlkID0gY29uZmlnLmlmcmFtZUVsZW1lbnRJZDtcbiAgICAgICAgaWZyYW1lLnNyYyA9IGNvbmZpZy5pZnJhbWVVcmw7XG4gICAgICAgIHRoaXMuaWZyYW1lID0gaWZyYW1lO1xuICAgICAgICBjb25zdCBpZnJhbWVVcmwgPSBuZXcgVVJMKGNvbmZpZy5pZnJhbWVVcmwpO1xuICAgICAgICB0aGlzLmlmcmFtZU9yaWdpbiA9IGlmcmFtZVVybC5vcmlnaW47XG4gICAgICAgIC8vIFRoaXMgaXMgcG9wdWxhdGVkIG9uY2UgdGhlIGlmcmFtZSBpcyByZWFkeS4gQ2FsbCBgLmluaXQoKWAgdG8ga2ljayBvZmYgRE9NIGluc2VydGlvbiFcbiAgICAgICAgdGhpcy5pZnJhbWVQdWJsaWNLZXkgPSBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnNlcnRzIHRoZSBpZnJhbWUgb24gdGhlIHBhZ2UgYW5kIHJldHVybnMgYSBwcm9taXNlIHJlc29sdmluZyB0byB0aGUgaWZyYW1lJ3MgcHVibGljIGtleVxuICAgICAqL1xuICAgIGFzeW5jIGluaXQoKSB7XG4gICAgICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuaWZyYW1lKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCBfcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50Lm9yaWdpbiAhPT0gdGhpcy5pZnJhbWVPcmlnaW4pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlcmUgbWlnaHQgYmUgb3RoZXIgdGhpbmdzIGdvaW5nIG9uIGluIHRoZSB3aW5kb3csIGZvciBleGFtcGxlOiByZWFjdCBkZXYgdG9vbHMsIG90aGVyIGV4dGVuc2lvbnMsIGV0Yy5cbiAgICAgICAgICAgICAgICAgICAgLy8gSW5zdGVhZCBvZiBlcnJvcmluZyBvdXRcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQuZGF0YT8udHlwZSA9PT0gSWZyYW1lRXZlbnRUeXBlLlB1YmxpY0tleVJlYWR5KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaWZyYW1lUHVibGljS2V5ID0gZXZlbnQuZGF0YVtcInZhbHVlXCJdO1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGV2ZW50LmRhdGFbXCJ2YWx1ZVwiXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgZmFsc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyB0aGUgaWZyYW1lIGZyb20gdGhlIERPTVxuICAgICAqL1xuICAgIGNsZWFyKCkge1xuICAgICAgICB0aGlzLmlmcmFtZS5yZW1vdmUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcHVibGljIGtleSwgb3IgYG51bGxgIGlmIHRoZSB1bmRlcmx5aW5nIGlmcmFtZSBpc24ndCBwcm9wZXJseSBpbml0aWFsaXplZC5cbiAgICAgKi9cbiAgICBwdWJsaWNLZXkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlmcmFtZVB1YmxpY0tleTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRnVuY3Rpb24gdG8gaW5qZWN0IGEgbmV3IGNyZWRlbnRpYWwgaW50byB0aGUgaWZyYW1lXG4gICAgICogVGhlIGJ1bmRsZSBzaG91bGQgYmUgZW5jcnlwdGVkIHRvIHRoZSBpZnJhbWUncyBpbml0aWFsIHB1YmxpYyBrZXlcbiAgICAgKiBFbmNyeXB0aW9uIHNob3VsZCBiZSBwZXJmb3JtZWQgd2l0aCBIUEtFIChSRkMgOTE4MCkuXG4gICAgICogVGhpcyBpcyB1c2VkIGR1cmluZyByZWNvdmVyeSBhbmQgYXV0aCBmbG93cy5cbiAgICAgKi9cbiAgICBhc3luYyBpbmplY3RDcmVkZW50aWFsQnVuZGxlKGJ1bmRsZSkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5pZnJhbWUuY29udGVudFdpbmRvdz8ucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgIHR5cGU6IElmcmFtZUV2ZW50VHlwZS5JbmplY3RDcmVkZW50aWFsQnVuZGxlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBidW5kbGUsXG4gICAgICAgICAgICB9LCBcIipcIik7XG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50Lm9yaWdpbiAhPT0gdGhpcy5pZnJhbWVPcmlnaW4pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlcmUgbWlnaHQgYmUgb3RoZXIgdGhpbmdzIGdvaW5nIG9uIGluIHRoZSB3aW5kb3csIGZvciBleGFtcGxlOiByZWFjdCBkZXYgdG9vbHMsIG90aGVyIGV4dGVuc2lvbnMsIGV0Yy5cbiAgICAgICAgICAgICAgICAgICAgLy8gSW5zdGVhZCBvZiBlcnJvcmluZyBvdXQgd2Ugc2ltcGx5IHJldHVybi4gTm90IG91ciBldmVudCFcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQuZGF0YT8udHlwZSA9PT0gSWZyYW1lRXZlbnRUeXBlLkJ1bmRsZUluamVjdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoZXZlbnQuZGF0YVtcInZhbHVlXCJdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50LmRhdGE/LnR5cGUgPT09IElmcmFtZUV2ZW50VHlwZS5FcnJvcikge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXZlbnQuZGF0YVtcInZhbHVlXCJdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBmYWxzZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGdW5jdGlvbiB0byBpbmplY3QgYW4gZXhwb3J0IGJ1bmRsZSBpbnRvIHRoZSBpZnJhbWVcbiAgICAgKiBUaGUgYnVuZGxlIHNob3VsZCBiZSBlbmNyeXB0ZWQgdG8gdGhlIGlmcmFtZSdzIGluaXRpYWwgcHVibGljIGtleVxuICAgICAqIEVuY3J5cHRpb24gc2hvdWxkIGJlIHBlcmZvcm1lZCB3aXRoIEhQS0UgKFJGQyA5MTgwKS5cbiAgICAgKiBUaGUga2V5IGZvcm1hdCB0byBlbmNvZGUgdGhlIHByaXZhdGUga2V5IGluIGFmdGVyIGl0J3MgZXhwb3J0ZWQgYW5kIGRlY3J5cHRlZDogSEVYQURFQ0lNQUwgb3IgU09MQU5BLiBEZWZhdWx0cyB0byBIRVhBREVDSU1BTC5cbiAgICAgKiBUaGlzIGlzIHVzZWQgZHVyaW5nIHRoZSBwcml2YXRlIGtleSBleHBvcnQgZmxvdy5cbiAgICAgKi9cbiAgICBhc3luYyBpbmplY3RLZXlFeHBvcnRCdW5kbGUoYnVuZGxlLCBvcmdhbml6YXRpb25JZCwga2V5Rm9ybWF0KSB7XG4gICAgICAgIHRoaXMuaWZyYW1lLmNvbnRlbnRXaW5kb3c/LnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgIHR5cGU6IElmcmFtZUV2ZW50VHlwZS5JbmplY3RLZXlFeHBvcnRCdW5kbGUsXG4gICAgICAgICAgICB2YWx1ZTogYnVuZGxlLFxuICAgICAgICAgICAga2V5Rm9ybWF0LFxuICAgICAgICAgICAgb3JnYW5pemF0aW9uSWQsXG4gICAgICAgIH0sIFwiKlwiKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQub3JpZ2luICE9PSB0aGlzLmlmcmFtZU9yaWdpbikge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGVyZSBtaWdodCBiZSBvdGhlciB0aGluZ3MgZ29pbmcgb24gaW4gdGhlIHdpbmRvdywgZm9yIGV4YW1wbGU6IHJlYWN0IGRldiB0b29scywgb3RoZXIgZXh0ZW5zaW9ucywgZXRjLlxuICAgICAgICAgICAgICAgICAgICAvLyBJbnN0ZWFkIG9mIGVycm9yaW5nIG91dCB3ZSBzaW1wbHkgcmV0dXJuLiBOb3Qgb3VyIGV2ZW50IVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChldmVudC5kYXRhPy50eXBlID09PSBJZnJhbWVFdmVudFR5cGUuQnVuZGxlSW5qZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShldmVudC5kYXRhW1widmFsdWVcIl0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQuZGF0YT8udHlwZSA9PT0gSWZyYW1lRXZlbnRUeXBlLkVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChldmVudC5kYXRhW1widmFsdWVcIl0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIGZhbHNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZ1bmN0aW9uIHRvIGluamVjdCBhbiBleHBvcnQgYnVuZGxlIGludG8gdGhlIGlmcmFtZVxuICAgICAqIFRoZSBidW5kbGUgc2hvdWxkIGJlIGVuY3J5cHRlZCB0byB0aGUgaWZyYW1lJ3MgaW5pdGlhbCBwdWJsaWMga2V5XG4gICAgICogRW5jcnlwdGlvbiBzaG91bGQgYmUgcGVyZm9ybWVkIHdpdGggSFBLRSAoUkZDIDkxODApLlxuICAgICAqIFRoaXMgaXMgdXNlZCBkdXJpbmcgdGhlIHdhbGxldCBleHBvcnQgZmxvdy5cbiAgICAgKi9cbiAgICBhc3luYyBpbmplY3RXYWxsZXRFeHBvcnRCdW5kbGUoYnVuZGxlLCBvcmdhbml6YXRpb25JZCkge1xuICAgICAgICB0aGlzLmlmcmFtZS5jb250ZW50V2luZG93Py5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICB0eXBlOiBJZnJhbWVFdmVudFR5cGUuSW5qZWN0V2FsbGV0RXhwb3J0QnVuZGxlLFxuICAgICAgICAgICAgdmFsdWU6IGJ1bmRsZSxcbiAgICAgICAgICAgIG9yZ2FuaXphdGlvbklkLFxuICAgICAgICB9LCBcIipcIik7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50Lm9yaWdpbiAhPT0gdGhpcy5pZnJhbWVPcmlnaW4pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlcmUgbWlnaHQgYmUgb3RoZXIgdGhpbmdzIGdvaW5nIG9uIGluIHRoZSB3aW5kb3csIGZvciBleGFtcGxlOiByZWFjdCBkZXYgdG9vbHMsIG90aGVyIGV4dGVuc2lvbnMsIGV0Yy5cbiAgICAgICAgICAgICAgICAgICAgLy8gSW5zdGVhZCBvZiBlcnJvcmluZyBvdXQgd2Ugc2ltcGx5IHJldHVybi4gTm90IG91ciBldmVudCFcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQuZGF0YT8udHlwZSA9PT0gSWZyYW1lRXZlbnRUeXBlLkJ1bmRsZUluamVjdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoZXZlbnQuZGF0YVtcInZhbHVlXCJdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50LmRhdGE/LnR5cGUgPT09IElmcmFtZUV2ZW50VHlwZS5FcnJvcikge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXZlbnQuZGF0YVtcInZhbHVlXCJdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBmYWxzZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGdW5jdGlvbiB0byBpbmplY3QgYW4gaW1wb3J0IGJ1bmRsZSBpbnRvIHRoZSBpZnJhbWVcbiAgICAgKiBUaGlzIGlzIHVzZWQgdG8gaW5pdGlhdGUgZWl0aGVyIHRoZSB3YWxsZXQgaW1wb3J0IGZsb3cgb3IgdGhlIHByaXZhdGUga2V5IGltcG9ydCBmbG93LlxuICAgICAqL1xuICAgIGFzeW5jIGluamVjdEltcG9ydEJ1bmRsZShidW5kbGUsIG9yZ2FuaXphdGlvbklkLCB1c2VySWQpIHtcbiAgICAgICAgdGhpcy5pZnJhbWUuY29udGVudFdpbmRvdz8ucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgdHlwZTogSWZyYW1lRXZlbnRUeXBlLkluamVjdEltcG9ydEJ1bmRsZSxcbiAgICAgICAgICAgIHZhbHVlOiBidW5kbGUsXG4gICAgICAgICAgICBvcmdhbml6YXRpb25JZCxcbiAgICAgICAgICAgIHVzZXJJZCxcbiAgICAgICAgfSwgXCIqXCIpO1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChldmVudC5vcmlnaW4gIT09IHRoaXMuaWZyYW1lT3JpZ2luKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZXJlIG1pZ2h0IGJlIG90aGVyIHRoaW5ncyBnb2luZyBvbiBpbiB0aGUgd2luZG93LCBmb3IgZXhhbXBsZTogcmVhY3QgZGV2IHRvb2xzLCBvdGhlciBleHRlbnNpb25zLCBldGMuXG4gICAgICAgICAgICAgICAgICAgIC8vIEluc3RlYWQgb2YgZXJyb3Jpbmcgb3V0IHdlIHNpbXBseSByZXR1cm4uIE5vdCBvdXIgZXZlbnQhXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50LmRhdGE/LnR5cGUgPT09IElmcmFtZUV2ZW50VHlwZS5CdW5kbGVJbmplY3RlZCkge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGV2ZW50LmRhdGFbXCJ2YWx1ZVwiXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChldmVudC5kYXRhPy50eXBlID09PSBJZnJhbWVFdmVudFR5cGUuRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGV2ZW50LmRhdGFbXCJ2YWx1ZVwiXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgZmFsc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRnVuY3Rpb24gdG8gZXh0cmFjdCBhbiBlbmNyeXB0ZWQgYnVuZGxlIGZyb20gdGhlIGlmcmFtZVxuICAgICAqIFRoZSBidW5kbGUgc2hvdWxkIGJlIGVuY3J5cHRlZCB0byBUdXJua2V5J3MgU2lnbmVyIGVuY2xhdmUncyBpbml0aWFsIHB1YmxpYyBrZXlcbiAgICAgKiBFbmNyeXB0aW9uIHNob3VsZCBiZSBwZXJmb3JtZWQgd2l0aCBIUEtFIChSRkMgOTE4MCkuXG4gICAgICogVGhpcyBpcyB1c2VkIGR1cmluZyB0aGUgd2FsbGV0IGltcG9ydCBmbG93LlxuICAgICAqL1xuICAgIGFzeW5jIGV4dHJhY3RXYWxsZXRFbmNyeXB0ZWRCdW5kbGUoKSB7XG4gICAgICAgIHRoaXMuaWZyYW1lLmNvbnRlbnRXaW5kb3c/LnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgIHR5cGU6IElmcmFtZUV2ZW50VHlwZS5FeHRyYWN0V2FsbGV0RW5jcnlwdGVkQnVuZGxlLFxuICAgICAgICB9LCBcIipcIik7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50Lm9yaWdpbiAhPT0gdGhpcy5pZnJhbWVPcmlnaW4pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlcmUgbWlnaHQgYmUgb3RoZXIgdGhpbmdzIGdvaW5nIG9uIGluIHRoZSB3aW5kb3csIGZvciBleGFtcGxlOiByZWFjdCBkZXYgdG9vbHMsIG90aGVyIGV4dGVuc2lvbnMsIGV0Yy5cbiAgICAgICAgICAgICAgICAgICAgLy8gSW5zdGVhZCBvZiBlcnJvcmluZyBvdXQgd2Ugc2ltcGx5IHJldHVybi4gTm90IG91ciBldmVudCFcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQuZGF0YT8udHlwZSA9PT0gSWZyYW1lRXZlbnRUeXBlLkVuY3J5cHRlZEJ1bmRsZUV4dHJhY3RlZCkge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGV2ZW50LmRhdGFbXCJ2YWx1ZVwiXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChldmVudC5kYXRhPy50eXBlID09PSBJZnJhbWVFdmVudFR5cGUuRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGV2ZW50LmRhdGFbXCJ2YWx1ZVwiXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgZmFsc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRnVuY3Rpb24gdG8gZXh0cmFjdCBhbiBlbmNyeXB0ZWQgYnVuZGxlIGZyb20gdGhlIGlmcmFtZVxuICAgICAqIFRoZSBidW5kbGUgc2hvdWxkIGJlIGVuY3J5cHRlZCB0byBUdXJua2V5J3MgU2lnbmVyIGVuY2xhdmUncyBpbml0aWFsIHB1YmxpYyBrZXlcbiAgICAgKiBFbmNyeXB0aW9uIHNob3VsZCBiZSBwZXJmb3JtZWQgd2l0aCBIUEtFIChSRkMgOTE4MCkuXG4gICAgICogVGhlIGtleSBmb3JtYXQgdG8gZW5jb2RlIHRoZSBwcml2YXRlIGtleSBpbiBiZWZvcmUgaXQncyBlbmNyeXB0ZWQgYW5kIGltcG9ydGVkOiBIRVhBREVDSU1BTCBvciBTT0xBTkEuIERlZmF1bHRzIHRvIEhFWEFERUNJTUFMLlxuICAgICAqIFRoaXMgaXMgdXNlZCBkdXJpbmcgdGhlIHByaXZhdGUga2V5IGltcG9ydCBmbG93LlxuICAgICAqL1xuICAgIGFzeW5jIGV4dHJhY3RLZXlFbmNyeXB0ZWRCdW5kbGUoa2V5Rm9ybWF0KSB7XG4gICAgICAgIHRoaXMuaWZyYW1lLmNvbnRlbnRXaW5kb3c/LnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgIHR5cGU6IElmcmFtZUV2ZW50VHlwZS5FeHRyYWN0S2V5RW5jcnlwdGVkQnVuZGxlLFxuICAgICAgICAgICAga2V5Rm9ybWF0OiBrZXlGb3JtYXQsXG4gICAgICAgIH0sIFwiKlwiKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQub3JpZ2luICE9PSB0aGlzLmlmcmFtZU9yaWdpbikge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGVyZSBtaWdodCBiZSBvdGhlciB0aGluZ3MgZ29pbmcgb24gaW4gdGhlIHdpbmRvdywgZm9yIGV4YW1wbGU6IHJlYWN0IGRldiB0b29scywgb3RoZXIgZXh0ZW5zaW9ucywgZXRjLlxuICAgICAgICAgICAgICAgICAgICAvLyBJbnN0ZWFkIG9mIGVycm9yaW5nIG91dCB3ZSBzaW1wbHkgcmV0dXJuLiBOb3Qgb3VyIGV2ZW50IVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChldmVudC5kYXRhPy50eXBlID09PSBJZnJhbWVFdmVudFR5cGUuRW5jcnlwdGVkQnVuZGxlRXh0cmFjdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoZXZlbnQuZGF0YVtcInZhbHVlXCJdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50LmRhdGE/LnR5cGUgPT09IElmcmFtZUV2ZW50VHlwZS5FcnJvcikge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXZlbnQuZGF0YVtcInZhbHVlXCJdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBmYWxzZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGdW5jdGlvbiB0byBhcHBseSBzZXR0aW5ncyBvbiBhbGxvd2VkIHBhcmFtZXRlcnMgaW4gdGhlIGlmcmFtZVxuICAgICAqIFRoaXMgaXMgdXNlZCB0byBzdHlsZSB0aGUgSFRNTCBlbGVtZW50IHVzZWQgZm9yIHBsYWludGV4dCBpbiB3YWxsZXQgYW5kIHByaXZhdGUga2V5IGltcG9ydC5cbiAgICAgKi9cbiAgICBhc3luYyBhcHBseVNldHRpbmdzKHNldHRpbmdzKSB7XG4gICAgICAgIGNvbnN0IHNldHRpbmdzU3RyID0gSlNPTi5zdHJpbmdpZnkoc2V0dGluZ3MpO1xuICAgICAgICB0aGlzLmlmcmFtZS5jb250ZW50V2luZG93Py5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICB0eXBlOiBJZnJhbWVFdmVudFR5cGUuQXBwbHlTZXR0aW5ncyxcbiAgICAgICAgICAgIHZhbHVlOiBzZXR0aW5nc1N0cixcbiAgICAgICAgfSwgXCIqXCIpO1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChldmVudC5vcmlnaW4gIT09IHRoaXMuaWZyYW1lT3JpZ2luKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZXJlIG1pZ2h0IGJlIG90aGVyIHRoaW5ncyBnb2luZyBvbiBpbiB0aGUgd2luZG93LCBmb3IgZXhhbXBsZTogcmVhY3QgZGV2IHRvb2xzLCBvdGhlciBleHRlbnNpb25zLCBldGMuXG4gICAgICAgICAgICAgICAgICAgIC8vIEluc3RlYWQgb2YgZXJyb3Jpbmcgb3V0IHdlIHNpbXBseSByZXR1cm4uIE5vdCBvdXIgZXZlbnQhXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50LmRhdGE/LnR5cGUgPT09IElmcmFtZUV2ZW50VHlwZS5TZXR0aW5nc0FwcGxpZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShldmVudC5kYXRhW1widmFsdWVcIl0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQuZGF0YT8udHlwZSA9PT0gSWZyYW1lRXZlbnRUeXBlLkVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChldmVudC5kYXRhW1widmFsdWVcIl0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIGZhbHNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZ1bmN0aW9uIHRvIHNpZ24gYSBwYXlsb2FkIHdpdGggdGhlIHVuZGVybHlpbmcgaWZyYW1lXG4gICAgICovXG4gICAgYXN5bmMgc3RhbXAocGF5bG9hZCkge1xuICAgICAgICBpZiAodGhpcy5pZnJhbWVQdWJsaWNLZXkgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm51bGwgaWZyYW1lIHB1YmxpYyBrZXkuIEhhdmUgeW91IGNhbGxlZC9hd2FpdGVkIC5pbml0KCk/XCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlmcmFtZU9yaWdpbiA9IHRoaXMuaWZyYW1lT3JpZ2luO1xuICAgICAgICB0aGlzLmlmcmFtZS5jb250ZW50V2luZG93Py5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICB0eXBlOiBJZnJhbWVFdmVudFR5cGUuU3RhbXBSZXF1ZXN0LFxuICAgICAgICAgICAgdmFsdWU6IHBheWxvYWQsXG4gICAgICAgIH0sIFwiKlwiKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQub3JpZ2luICE9PSBpZnJhbWVPcmlnaW4pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlcmUgbWlnaHQgYmUgb3RoZXIgdGhpbmdzIGdvaW5nIG9uIGluIHRoZSB3aW5kb3csIGZvciBleGFtcGxlOiByZWFjdCBkZXYgdG9vbHMsIG90aGVyIGV4dGVuc2lvbnMsIGV0Yy5cbiAgICAgICAgICAgICAgICAgICAgLy8gSW5zdGVhZCBvZiBlcnJvcmluZyBvdXQgd2Ugc2ltcGx5IHJldHVybi4gTm90IG91ciBldmVudCFcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQuZGF0YT8udHlwZSA9PT0gSWZyYW1lRXZlbnRUeXBlLlN0YW1wKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhbXBIZWFkZXJOYW1lOiBzdGFtcEhlYWRlck5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFtcEhlYWRlclZhbHVlOiBldmVudC5kYXRhW1widmFsdWVcIl0sXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQuZGF0YT8udHlwZSA9PT0gSWZyYW1lRXZlbnRUeXBlLkVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChldmVudC5kYXRhW1widmFsdWVcIl0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIGZhbHNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG5leHBvcnQgeyBJZnJhbWVFdmVudFR5cGUsIElmcmFtZVN0YW1wZXIsIEtleUZvcm1hdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/@turnkey+iframe-stamper@2.0.0/node_modules/@turnkey/iframe-stamper/dist/index.mjs\n");

/***/ })

};
;